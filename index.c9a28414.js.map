{"mappings":"ACAA,SAAS,gBAAgB,CAAC,mBAAoB,KAC1C,IAAM,EAAmB,SAAS,cAAc,CAAC,qBAC3C,EAAO,SAAS,IAAI,CAEtB,EAA0B,CAAA,EAC1B,EAAqB,CAAA,EACrB,EAAmB,EAwCvB,SAAS,EAAuB,CAAK,EACjC,GAAI,CAAC,GAA2B,AAAiB,IAAjB,EAAM,MAAM,CAAQ,OAEpD,IAAM,EAAgB,EAAiB,WAAW,CAAG,EAAiB,WAAW,CAC3E,EAAoB,EAAiB,UAAU,CAC/C,EAAe,AA5CK,GA4CL,EAAM,MAAM,AAE7B,CAAA,EAAM,MAAM,CAAG,EAEX,EAAoB,GACpB,EAAM,cAAc,GACpB,GAAoB,IAGpB,EAAK,KAAK,CAAC,SAAS,CAAG,OACvB,EAA0B,CAAA,EAC1B,OAAO,mBAAmB,CAAC,QAAS,IAIpC,EAAoB,GACpB,EAAM,cAAc,GACpB,GAAoB,IAGpB,EAAK,KAAK,CAAC,SAAS,CAAG,OACvB,EAA0B,CAAA,EAC1B,OAAO,mBAAmB,CAAC,QAAS,GAGhD,CAhCA,AAnCiB,IAAI,qBAAqB,AAAA,IACtC,EAAQ,OAAO,CAAC,AAAA,IACZ,GAAI,EAAM,cAAc,CAAE,CAClB,EAAM,kBAAkB,CAAC,GAAG,CAAG,GAC/B,EAAqB,CAAA,EACrB,EAAiB,UAAU,CAAG,EAAiB,WAAW,CAAG,EAAiB,WAAW,EAEzF,EAAqB,CAAA,EAIzB,IAAM,EAAiB,EAAiB,qBAAqB,GAAG,GAAG,CAAG,OAAO,OAAO,CAAI,CAAA,OAAO,WAAW,CAAG,EAAI,EAAiB,YAAY,CAAG,CAAA,EACjJ,OAAO,QAAQ,CAAC,CACZ,IAAK,EACL,SAAU,QACd,GAEA,EAA0B,CAAA,EAC1B,EAAK,KAAK,CAAC,SAAS,CAAG,SACvB,OAAO,gBAAgB,CAAC,QAAS,EAAwB,CAAE,QAAS,CAAA,CAAM,EAC9E,MACQ,GAAsB,AAAgC,IAAhC,EAAiB,UAAU,EAEjD,EAAK,KAAK,CAAC,SAAS,CAAG,OACvB,EAA0B,CAAA,GAClB,GACR,CAAA,EAAK,KAAK,CAAC,SAAS,CAAG,MAD3B,EAGA,OAAO,mBAAmB,CAAC,QAAS,EAE5C,EACJ,EAAG,CACC,UAAW,EACf,GAES,OAAO,CAAC,GAuCjB,IAAM,EAAa,SAAS,sBAAsB,CAAC,wBAAwB,CAAC,EAAE,CACxE,EAAS,EAAW,qBAAqB,GAAG,MAAM,CAAG,EAEvD,EAAS,CAEb,CAAA,EAAK,KAAK,CAAC,MAAM,CAAG,KAAK,KAAK,CAAC,GAAU,KAezC,AAbA,SAAS,IAEL,GAAK,EAKa,OAAO,OAAO,KALF,CAE1B,IAAM,EAAS,eADf,CAAA,GAAW,AAAA,CAAA,OAAO,OAAO,CAAG,CAAA,EARtB,GAQN,EACyC,mBACzC,CAAA,EAAW,KAAK,CAAC,SAAS,CAAG,CACjC,CAIA,sBAAsB,EAC1B,IAGA,AA1BA,SAAS,IACL,EAAiB,UAAU,EAAI,AAAC,CAAA,EAAmB,EAAiB,UAAU,AAAV,EAAc,IAClF,sBAAsB,EAC1B,GAwBJ","sources":["<anon>","src/js/solutions.js"],"sourcesContent":["document.addEventListener(\"DOMContentLoaded\", ()=>{\n    const solutionsSection = document.getElementById(\"solutions-section\");\n    const body = document.body;\n    let isScrollingHorizontally = false;\n    let enteringFromBottom = false;\n    let horizontalOffset = 0;\n    const horizontalSpeedFactor = 0.8; // Adjust speed factor as needed for acceleration\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            if (entry.isIntersecting) {\n                if (entry.boundingClientRect.top < 0) {\n                    enteringFromBottom = true;\n                    solutionsSection.scrollLeft = solutionsSection.scrollWidth - solutionsSection.clientWidth;\n                } else enteringFromBottom = false;\n                // Center the solutionsSection vertically\n                const scrollToCenter = solutionsSection.getBoundingClientRect().top + window.scrollY - (window.innerHeight / 2 - solutionsSection.clientHeight / 2);\n                window.scrollTo({\n                    top: scrollToCenter,\n                    behavior: \"smooth\"\n                });\n                isScrollingHorizontally = true;\n                body.style.overflowY = \"hidden\";\n                window.addEventListener(\"wheel\", handleHorizontalScroll, {\n                    passive: false\n                });\n            } else {\n                if (enteringFromBottom && solutionsSection.scrollLeft === 0) {\n                    // Allow vertical scroll after reaching the start when entering from the bottom\n                    body.style.overflowY = \"auto\";\n                    isScrollingHorizontally = false;\n                } else if (!enteringFromBottom) body.style.overflowY = \"auto\";\n                window.removeEventListener(\"wheel\", handleHorizontalScroll);\n            }\n        });\n    }, {\n        threshold: 0.7\n    });\n    observer.observe(solutionsSection);\n    function handleHorizontalScroll(event) {\n        if (!isScrollingHorizontally || event.deltaY === 0) return;\n        const scrollLeftMax = solutionsSection.scrollWidth - solutionsSection.clientWidth;\n        const scrollLeftCurrent = solutionsSection.scrollLeft;\n        const scrollAmount = event.deltaY * horizontalSpeedFactor;\n        if (event.deltaY > 0) {\n            // Scrolling down/right\n            if (scrollLeftCurrent < scrollLeftMax) {\n                event.preventDefault();\n                horizontalOffset += scrollAmount;\n            } else {\n                // Allow vertical scroll after reaching the end\n                body.style.overflowY = \"auto\";\n                isScrollingHorizontally = false;\n                window.removeEventListener(\"wheel\", handleHorizontalScroll);\n            }\n        } else // Scrolling up/left\n        if (scrollLeftCurrent > 0) {\n            event.preventDefault();\n            horizontalOffset += scrollAmount;\n        } else {\n            // Allow vertical scroll after reaching the start\n            body.style.overflowY = \"auto\";\n            isScrollingHorizontally = false;\n            window.removeEventListener(\"wheel\", handleHorizontalScroll);\n        }\n    }\n    function smoothHorizontalScroll() {\n        solutionsSection.scrollLeft += (horizontalOffset - solutionsSection.scrollLeft) * 0.05; // Increase smoothness\n        requestAnimationFrame(smoothHorizontalScroll);\n    }\n    const scrollWrap = document.getElementsByClassName(\"smooth-scroll-wrapper\")[0];\n    const height = scrollWrap.getBoundingClientRect().height - 1;\n    const speed = 0.01;\n    let offset = 0;\n    body.style.height = Math.floor(height) + \"px\";\n    function smoothScroll() {\n        let lastYOffset = 0;\n        if (!isScrollingHorizontally) {\n            offset += (window.scrollY - offset) * speed;\n            const scroll = \"translateY(-\" + offset + \"px) translateZ(0)\";\n            scrollWrap.style.transform = scroll;\n        } else lastYOffset = window.scrollY;\n        requestAnimationFrame(smoothScroll);\n    }\n    smoothScroll();\n    smoothHorizontalScroll();\n});\n\n//# sourceMappingURL=index.c9a28414.js.map\n","document.addEventListener('DOMContentLoaded', () => {\r\n    const solutionsSection = document.getElementById('solutions-section');\r\n    const body = document.body;\r\n\r\n    let isScrollingHorizontally = false;\r\n    let enteringFromBottom = false;\r\n    let horizontalOffset = 0;\r\n    const horizontalSpeedFactor = 0.8; // Adjust speed factor as needed for acceleration\r\n\r\n    const observer = new IntersectionObserver(entries => {\r\n        entries.forEach(entry => {\r\n            if (entry.isIntersecting) {\r\n                if (entry.boundingClientRect.top < 0) {\r\n                    enteringFromBottom = true;\r\n                    solutionsSection.scrollLeft = solutionsSection.scrollWidth - solutionsSection.clientWidth;\r\n                } else {\r\n                    enteringFromBottom = false;\r\n                }\r\n\r\n                // Center the solutionsSection vertically\r\n                const scrollToCenter = solutionsSection.getBoundingClientRect().top + window.scrollY - (window.innerHeight / 2 - solutionsSection.clientHeight / 2);\r\n                window.scrollTo({\r\n                    top: scrollToCenter,\r\n                    behavior: 'smooth'\r\n                });\r\n\r\n                isScrollingHorizontally = true;\r\n                body.style.overflowY = 'hidden';\r\n                window.addEventListener('wheel', handleHorizontalScroll, { passive: false });\r\n            } else {\r\n                if (enteringFromBottom && solutionsSection.scrollLeft === 0) {\r\n                    // Allow vertical scroll after reaching the start when entering from the bottom\r\n                    body.style.overflowY = 'auto';\r\n                    isScrollingHorizontally = false;\r\n                } else if (!enteringFromBottom) {\r\n                    body.style.overflowY = 'auto';\r\n                }\r\n                window.removeEventListener('wheel', handleHorizontalScroll);\r\n            }\r\n        });\r\n    }, {\r\n        threshold: 0.7\r\n    });\r\n\r\n    observer.observe(solutionsSection);\r\n\r\n    function handleHorizontalScroll(event) {\r\n        if (!isScrollingHorizontally || event.deltaY === 0) return;\r\n\r\n        const scrollLeftMax = solutionsSection.scrollWidth - solutionsSection.clientWidth;\r\n        const scrollLeftCurrent = solutionsSection.scrollLeft;\r\n        const scrollAmount = event.deltaY * horizontalSpeedFactor;\r\n\r\n        if (event.deltaY > 0) {\r\n            // Scrolling down/right\r\n            if (scrollLeftCurrent < scrollLeftMax) {\r\n                event.preventDefault();\r\n                horizontalOffset += scrollAmount;\r\n            } else {\r\n                // Allow vertical scroll after reaching the end\r\n                body.style.overflowY = 'auto';\r\n                isScrollingHorizontally = false;\r\n                window.removeEventListener('wheel', handleHorizontalScroll);\r\n            }\r\n        } else {\r\n            // Scrolling up/left\r\n            if (scrollLeftCurrent > 0) {\r\n                event.preventDefault();\r\n                horizontalOffset += scrollAmount;\r\n            } else {\r\n                // Allow vertical scroll after reaching the start\r\n                body.style.overflowY = 'auto';\r\n                isScrollingHorizontally = false;\r\n                window.removeEventListener('wheel', handleHorizontalScroll);\r\n            }\r\n        }\r\n    }\r\n\r\n    function smoothHorizontalScroll() {\r\n        solutionsSection.scrollLeft += (horizontalOffset - solutionsSection.scrollLeft) * 0.05; // Increase smoothness\r\n        requestAnimationFrame(smoothHorizontalScroll);\r\n    }\r\n\r\n    const scrollWrap = document.getElementsByClassName(\"smooth-scroll-wrapper\")[0];\r\n    const height = scrollWrap.getBoundingClientRect().height - 1;\r\n    const speed = 0.01;\r\n    let offset = 0;\r\n    \r\n    body.style.height = Math.floor(height) + \"px\";\r\n    \r\n    function smoothScroll() {\r\n        let lastYOffset = 0;\r\n        if (!isScrollingHorizontally) {\r\n            offset += (window.scrollY - offset) * speed;\r\n            const scroll = \"translateY(-\" + offset + \"px) translateZ(0)\";\r\n            scrollWrap.style.transform = scroll;\r\n        } else {\r\n            lastYOffset = window.scrollY;\r\n        }\r\n\r\n        requestAnimationFrame(smoothScroll);\r\n    }\r\n\r\n    smoothScroll();\r\n    smoothHorizontalScroll();\r\n});"],"names":["document","addEventListener","solutionsSection","getElementById","body","isScrollingHorizontally","enteringFromBottom","horizontalOffset","handleHorizontalScroll","event","deltaY","scrollLeftMax","scrollWidth","clientWidth","scrollLeftCurrent","scrollLeft","scrollAmount","preventDefault","style","overflowY","window","removeEventListener","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","boundingClientRect","top","scrollToCenter","getBoundingClientRect","scrollY","innerHeight","clientHeight","scrollTo","behavior","passive","threshold","observe","scrollWrap","getElementsByClassName","height","offset","Math","floor","smoothScroll","scroll","transform","requestAnimationFrame","smoothHorizontalScroll"],"version":3,"file":"index.c9a28414.js.map"}